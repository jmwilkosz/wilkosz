{"version":3,"file":"dialog-container.js","sourceRoot":"","sources":["../../../../src/lib/dialog/dialog-container.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Component,\n  ComponentRef,\n  ViewChild,\n  ViewEncapsulation,\n  NgZone,\n  OnDestroy,\n  Renderer,\n  ElementRef,\n  animate,\n  state,\n  style,\n  transition,\n  trigger,\n  AnimationTransitionEvent,\n  EventEmitter,\n} from '@angular/core';\nimport {BasePortalHost, ComponentPortal, PortalHostDirective, TemplatePortal} from '../core';\nimport {MdDialogConfig} from './dialog-config';\nimport {MdDialogContentAlreadyAttachedError} from './dialog-errors';\nimport {FocusTrapFactory, FocusTrap} from '../core/a11y/focus-trap';\nimport 'rxjs/add/operator/first';\n\n\n/** Possible states for the dialog container animation. */\nexport type MdDialogContainerAnimationState = 'void' | 'enter' | 'exit' | 'exit-start';\n\n\n/**\n * Internal component that wraps user-provided dialog content.\n * Animation is based on https://material.io/guidelines/motion/choreography.html.\n * @docs-private\n */\n@Component({\n  moduleId: module.id,\n  selector: 'md-dialog-container, mat-dialog-container',\n  templateUrl: 'dialog-container.html',\n  styleUrls: ['dialog.css'],\n  encapsulation: ViewEncapsulation.None,\n  animations: [\n    trigger('slideDialog', [\n      state('void', style({ transform: 'translateY(25%) scale(0.9)', opacity: 0 })),\n      state('enter', style({ transform: 'translateY(0%) scale(1)', opacity: 1 })),\n      state('exit', style({ transform: 'translateY(25%)', opacity: 0 })),\n      transition('* => *', animate('400ms cubic-bezier(0.25, 0.8, 0.25, 1)')),\n    ])\n  ],\n  host: {\n    '[class.mat-dialog-container]': 'true',\n    '[attr.role]': 'dialogConfig?.role',\n    '[@slideDialog]': '_state',\n    '(@slideDialog.done)': '_onAnimationDone($event)',\n  },\n})\nexport class MdDialogContainer extends BasePortalHost implements OnDestroy {\n  /** The portal host inside of this container into which the dialog content will be loaded. */\n  @ViewChild(PortalHostDirective) _portalHost: PortalHostDirective;\n\n  /** The class that traps and manages focus within the dialog. */\n  private _focusTrap: FocusTrap;\n\n  /** Element that was focused before the dialog was opened. Save this to restore upon close. */\n  private _elementFocusedBeforeDialogWasOpened: HTMLElement = null;\n\n  /** The dialog configuration. */\n  dialogConfig: MdDialogConfig;\n\n  /** State of the dialog animation. */\n  _state: MdDialogContainerAnimationState = 'enter';\n\n  /** Emits the current animation state whenever it changes. */\n  _onAnimationStateChange = new EventEmitter<MdDialogContainerAnimationState>();\n\n  constructor(\n    private _ngZone: NgZone,\n    private _renderer: Renderer,\n    private _elementRef: ElementRef,\n    private _focusTrapFactory: FocusTrapFactory) {\n\n    super();\n  }\n\n  /**\n   * Attach a ComponentPortal as content to this dialog container.\n   * @param portal Portal to be attached as the dialog content.\n   */\n  attachComponentPortal<T>(portal: ComponentPortal<T>): ComponentRef<T> {\n    if (this._portalHost.hasAttached()) {\n      throw new MdDialogContentAlreadyAttachedError();\n    }\n\n    let attachResult = this._portalHost.attachComponentPortal(portal);\n    this._trapFocus();\n    return attachResult;\n  }\n\n  /**\n   * Attach a TemplatePortal as content to this dialog container.\n   * @param portal Portal to be attached as the dialog content.\n   */\n  attachTemplatePortal(portal: TemplatePortal): Map<string, any> {\n    if (this._portalHost.hasAttached()) {\n      throw new MdDialogContentAlreadyAttachedError();\n    }\n\n    let attachedResult = this._portalHost.attachTemplatePortal(portal);\n    this._trapFocus();\n    return attachedResult;\n  }\n\n  /**\n   * Moves the focus inside the focus trap.\n   * @private\n   */\n  private _trapFocus() {\n    if (!this._focusTrap) {\n      this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);\n    }\n\n    // If were to attempt to focus immediately, then the content of the dialog would not yet be\n    // ready in instances where change detection has to run first. To deal with this, we simply\n    // wait for the microtask queue to be empty.\n    this._ngZone.onMicrotaskEmpty.first().subscribe(() => {\n      this._elementFocusedBeforeDialogWasOpened = document.activeElement as HTMLElement;\n      this._focusTrap.focusFirstTabbableElement();\n    });\n  }\n\n  /**\n   * Kicks off the leave animation.\n   * @docs-private\n   */\n  _exit(): void {\n    this._state = 'exit';\n    this._onAnimationStateChange.emit('exit-start');\n  }\n\n  /**\n   * Callback, invoked whenever an animation on the host completes.\n   * @docs-private\n   */\n  _onAnimationDone(event: AnimationTransitionEvent) {\n    this._onAnimationStateChange.emit(event.toState as MdDialogContainerAnimationState);\n  }\n\n  ngOnDestroy() {\n    // When the dialog is destroyed, return focus to the element that originally had it before\n    // the dialog was opened. Wait for the DOM to finish settling before changing the focus so\n    // that it doesn't end up back on the <body>. Also note that we need the extra check, because\n    // IE can set the `activeElement` to null in some cases.\n    this._ngZone.onMicrotaskEmpty.first().subscribe(() => {\n      let toFocus = this._elementFocusedBeforeDialogWasOpened as HTMLElement;\n\n      // We need to check whether the focus method exists at all, because IE seems to throw an\n      // exception, even if the element is the document.body.\n      if (toFocus && 'focus' in toFocus) {\n        toFocus.focus();\n      }\n\n      this._onAnimationStateChange.complete();\n    });\n\n    this._focusTrap.destroy();\n  }\n}\n"]}